---
title: 二进制编码与位运算
date: 2020-08-30 11:35:26
tags: ["golang"]
---

## 二进制编码

###  **二进制表示数**  

-   首位0 -> 正数   

-   首位1 -> 负数   

-   正数的源码 = 反码 = 补码

-   负数
    -   反码：源码符号位不变，其余位置取反 
    -   补码：反码+1 
    

-----

## 位运算

-   **👴位运算都使用补码运算👴**
-   **👴输出的结果再转回源码👴**

| 运算   | 符号 |                             规则                             |
| ------ | ---- | :----------------------------------------------------------: |
| 按位与 | &    |     对应二进制位都为1则为1,否则为0	->	有一个0则为0     |
| 按位或 | \|   |    对应二进制位都为0则为0,否则为1 	->	有一个1则为1     |
| 异或   | ^    | 一元 ^a	按位取反 <br>二元a^b	对应二进制位不同为1,相同为0	->	不进位加法 |
| 位清空 | &^   | a&^b	对于b的每个二进制位,如果为0,则取a对应位;如果为1,则取0	->	a&(^b) |
| 右移   | >>   | a>>b	a右移b位,符号位不变,低位溢出,高位用符号位补齐 -> 等价于a/(2^b)取下限 <br>负数不够除取-1 |
| 左移   | <<   |     a<<b	a左移b位,符号位不变,低位补0 -> 等价于a*(2^b)     |

<!--more-->

Eg.假设字长为8位

**10&-3**	0000 1010&1111 1101 -> 0000 1000 -> 8

**10|-3**	0000 1010|1111 1101 -> 1111 1111 -> -1

**10^-3**	0000 1010^1111 1101 -> 11110111 -> -9

**10&^-3**	0000 1010&^1111 1101 -> 0000 0010 -> 2

**1>>2**	0000 0001>>2 -> 0000 0000 -> 0

**-5>>3**	1111 1011>>2 ->1111 1111  -> -1

**-8<<2**	1111 1000<<2 -> 1110 0000 -> -32

-----

### 为什么用补码

源码就是最高位为符号位，其他位表示该数的绝对值 

正数可以直接加，有负数参与运算时就不能直接加了

**10+2** 0000 1010 + 0000 0010 =0000 1100 12

**10+-2** 0000 1010 + 1000 0010 =1000 1100 -12 🙅‍♀️

所以使用源码运算需要额外的减法器

而且还有正负0的问题


使用补码之后

**10+-2** 0000 1010 + 11111110 = 1 0000 1000 首位因为字长限制 结果保留8位 转成源码之后 即8



### 补码的本质

把-2替换成0-2

　００００００００ 

－００００００１０ 

－－－－－－－－－－ 

不够减 向上借位  0 可以 转化成 1111 1111 + 1  


　１１１１１１１１

－００００００１０

－－－－－－－－－ ⬇️

　１１１１１１０１

＋０００００００１

－－－－－－－－－ ⬇️

　１１１１１１１０

　1111 1110就是-2的补码

所以取反加一的意思就是表示用0减去这个数 

因为是有溢出的运算（模运算）
1111 1110 + 0000 0010 = 0
所以可以只用加法来进行计算
　

也就不难理解

```go
var a int8 = -128
/*
	golang中int后面的数字代表bit 
*/
a--
fmt.Println(a) //127
a++
fmt.Println(a) //-128
```

